using System;
using System.Linq;
using System.Xml;
using Interapptive.Shared.Threading;
using ShipWorks.Data.Model.EntityClasses;

namespace ShipWorks.Templates.Processing
{
    /// <summary>
    /// Used as a contextual object that exists through the life a template translation, providing input and progress services.
    /// </summary>
    public class TemplateTranslationContext
    {
        TemplateEntity template;
        TemplateInput input;
        IProgressReporter progress;

        int contextPosition = 0;
        int totalContexts = 1;

        int totalCustomers = 0;
        int processedCustomers = 0;

        bool processingComplete = false;

        NameTable nameTable;

        /// <summary>
        /// Constructor
        /// </summary>
        public TemplateTranslationContext(TemplateEntity template, TemplateInput input, IProgressReporter progress)
        {
            this.template = template;
            this.input = input;
            this.progress = progress;
            this.nameTable = new NameTable();
        }

        /// <summary>
        /// The template selected to do the transformation.  Can be null if processing tokens.
        /// </summary>
        public TemplateEntity Template
        {
            get { return template; }
        }

        /// <summary>
        /// The data input into the template
        /// </summary>
        public TemplateInput Input
        {
            get { return input; }
        }

        /// <summary>
        /// Get or set the progress detail message displayed to the user
        /// </summary>
        public string ProgressDetail
        {
            get { return progress.Detail; }
            set { progress.Detail = value; }
        }

        /// <summary>
        /// The NameTable to use during processing for more efficient XmlNode Name lookups
        /// </summary>
        public NameTable NameTable
        {
            get { return nameTable; }
        }

        /// <summary>
        /// If multiple translates are taking place, this sets the positino of this context and the total number of contexts to be processed.
        /// This helps with accurate progress display.
        /// </summary>
        public void SetContextPosition(int contextPosition, int totalContexts)
        {
            this.contextPosition = contextPosition;
            this.totalContexts = totalContexts;
        }

        /// <summary>
        /// The position of this context relative to all other contexts being processed in order.
        /// </summary>
        public int ContextPosition
        {
            get { return contextPosition; }
        }

        /// <summary>
        /// The total number of contexts beings sequentially processsed.
        /// </summary>
        public int TotalContexts
        {
            get { return totalContexts; }
        }

        /// <summary>
        /// Signal that a customer has been fetched as a part of processing.  This is the best indicator we have or progress.
        /// </summary>
        public void CustomerProcessed()
        {
            processedCustomers++;

            // First time a customer is processed, we grab the total
            if (processedCustomers == 1)
            {
                totalCustomers = input.GetCustomerKeys().Count();
            }

            UpdatePercentComplete();
        }

        /// <summary>
        /// Calculate the percentage complete based on the number of procesed customers, and our position relative to other translation contexts
        /// </summary>
        private void UpdatePercentComplete()
        {
            if (totalCustomers == 0)
            {
                progress.PercentComplete = 0;
            }
            else
            {
                double thisPercent = (double) processedCustomers / (double) totalCustomers;
                double amountDone = contextPosition + thisPercent;

                progress.PercentComplete = (int) (100 * amountDone / (double) totalContexts);
            }
        }

        /// <summary>
        /// Check to see if cancelation is requested.  If it is, throw a TemplateCancelException
        /// </summary>
        public void CheckForCancel()
        {
            if (progress.IsCancelRequested)
            {
                throw new TemplateCancelException();
            }
        }

        /// <summary>
        /// Indicates if template processing for this context\input has completed.  This was added to aid in debugging the TempalteXPathTree that gets
        /// generated by ensuring no new nodes are LazyInitialized after processing is complete, so the tree can be viewed without side effects. Setting this
        /// back to false enables the same TemplateTranslationContext to be used over again by the TemplateProcessor.
        /// </summary>
        public bool ProcessingComplete
        {
            get
            {
                return processingComplete;
            }
            set
            {
                if (processingComplete && value)
                {
                    throw new InvalidOperationException("ProcessingComplete has already been marked true.  If you need to process again, set ProcessingComplete to false first.");
                }

                processingComplete = value;
            }
        }
    }
}
